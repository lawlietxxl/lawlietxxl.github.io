<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://blog.lawlietxxl.site').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="日常用HashMap相关的类最多，但对其内部实现并不了解。花时间读些源码，整理了一下。 HashMap注释阅读 HashMap不是同步的，而且允许存在key和value是null，这是与HashTable的区别所在。 “in particular, it does not guarantee that the order will remain constant over time.”意思是，Ha">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap and LinkedHashMap">
<meta property="og:url" content="https://blog.lawlietxxl.site/HashMap%20and%20LinkedHashMap.html">
<meta property="og:site_name" content="lawlietxxl&#39;s blog">
<meta property="og:description" content="日常用HashMap相关的类最多，但对其内部实现并不了解。花时间读些源码，整理了一下。 HashMap注释阅读 HashMap不是同步的，而且允许存在key和value是null，这是与HashTable的区别所在。 “in particular, it does not guarantee that the order will remain constant over time.”意思是，Ha">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-08-05T21:17:58.000Z">
<meta property="article:modified_time" content="2020-01-12T10:12:03.400Z">
<meta property="article:author" content="lawlietxxl">
<meta property="article:tag" content="HashMap">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.lawlietxxl.site/HashMap%20and%20LinkedHashMap.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>HashMap and LinkedHashMap | lawlietxxl's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lawlietxxl's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.lawlietxxl.site/HashMap%20and%20LinkedHashMap.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lawlietxxl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lawlietxxl's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          HashMap and LinkedHashMap
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-05 14:17:58" itemprop="dateCreated datePublished" datetime="2018-08-05T14:17:58-07:00">2018-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-12 02:12:03" itemprop="dateModified" datetime="2020-01-12T02:12:03-08:00">2020-01-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">源码</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/%E6%BA%90%E7%A0%81/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/HashMap%20and%20LinkedHashMap.html#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="HashMap and LinkedHashMap.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>日常用HashMap相关的类最多，但对其内部实现并不了解。花时间读些源码，整理了一下。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="注释阅读"><a href="#注释阅读" class="headerlink" title="注释阅读"></a>注释阅读</h3><ul>
<li>HashMap不是同步的，而且允许存在key和value是null，这是与HashTable的区别所在。</li>
<li>“in particular, it does not guarantee that the order will remain constant over time.”意思是，HashMap中的键值对的顺序不是永远不变的（resize可能会造成键值对顺序改变）</li>
<li>HashMap的效率跟两个值相关——初始化的容量以及load factor。load factor是做rehash的时候map的容量标准。</li>
<li>HashMap不同步，所以在对HashMap做结构化操作（删除或者添加Mapping）的时候，一定要在外部做同步。或者使用 <code>Collections.synchronizedMap</code> 方法获取Map</li>
<li>Iterator提供一个HashMap的视图，在iterator外对HashMap进行结构性修改会抛出一个 <code>ConcurrentModificationException</code>异常，但是这并不能保证多线程安全。<a id="more"></a>
<h3 id="源码逻辑"><a href="#源码逻辑" class="headerlink" title="源码逻辑"></a>源码逻辑</h3><h4 id="fields-and-inner-class"><a href="#fields-and-inner-class" class="headerlink" title="fields and inner class"></a>fields and inner class</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//hash表</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; <span class="comment">// entrySet() values() 等函数用到的视图</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">// map中保存的entry数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">// 修改次数</span></span><br><span class="line">    <span class="keyword">int</span> threshold; <span class="comment">// resize的阈值，capacity * loadFactor</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Node 结构如下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当每个bucket内的node数目大于 TREEIFY_THRESHOLD 的时候，这个bucket下的链会treenify，为了提高查询效率</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>对于每个key的hash，HashMap做了一些转化：因为table的buckets数目是2的幂，选取bucket的时候是取模的运算，如果仅仅做hash值的模运算，<br>冲突会很多（低位一致的object都会冲突），所以把高位的影响转化到低位。做了效率和碰撞概率的tradeOff。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get Node的过程比较简单，首选通过入参 hash 判断Node在哪个bucket，判断当前bucket是treeNode还是Node，如果是树节点就调用树节点的方法，<br>如果是普通阶段就遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                    ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p>核心方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span></span></span><br></pre></td></tr></table></figure>
<p>代码较长，简要叙述过程：</p>
<p>put方法首先检查table是否进行了初始化，若否则调用resize进行初始化；<br>然后检查hash对应的bucket是否为null，若为null，则新建一个node填在bucket里面；若为treeNode就调用treeNode方法加入新节点，<br>若为普通node就弄一个新节点放到链表最后。普通node增加节点之后，判断节点数目是否大于 TREEIFY_THRESHOLD，若是则把链表树化<code>treeifyBin(tab, hash)</code></p>
<p>最后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++modCount; <span class="comment">//修改次数+1</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold) <span class="comment">//数目+1，如果大于阈值则调用resize</span></span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>remove是put的反过程，核心函数是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,<span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span></span></span><br></pre></td></tr></table></figure>
<p>代码较长，简要叙述过程：</p>
<p>与put一样，得到该hash和key对应的bucket位置，为null则返回null；不为null，判断该bucket node类型，若为TreeNode，则调用treeNode的方法获取node；<br>若为普通Node，则遍历，得到该Node点。然后进行remove，见函数，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node !=<span class="keyword">null</span>&amp;&amp;(!matchValue ||(v =node.value)==value ||</span><br><span class="line">            (value !=<span class="keyword">null</span>&amp;&amp;value.equals(v))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            ((TreeNode&lt;K, V&gt;) node).removeTreeNode(<span class="keyword">this</span>, tab, movable); <span class="comment">//treeNode调用remove方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">            tab[index] = node.next; <span class="comment">//node没有父节点，更新table</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.next = node.next; <span class="comment">//node在链上</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        --size;</span><br><span class="line">        afterNodeRemoval(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h4><p>resize函数负责把table扩大两倍，并且改变node位置（所以Map是只扩大不缩小的）；<br>根据前面的阅读，一个Node的位置是 (n-1)&amp;hash，所以一个node的位置要不变，要么位置*2。</p>
<p>大概做法是，搞两条链，low，high；然后特意强调了<strong>preserve order</strong>，把原节点的Node按照顺序放到这两条链中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//新建 Node数组，更新各个field，略</span></span><br><span class="line">    <span class="comment">//遍历oldTable的每个节点，对不同类型节点进行判断，做不同的处理</span></span><br><span class="line">    Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="keyword">if</span>((e =oldTab[j])!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">            newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            ((TreeNode&lt;K, V&gt;) e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">            Node&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K, V&gt; next;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                next = e.next;</span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">//注意oldCap是 100000...，通过此方法可以判断e是保持bucket不变的点</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                newTab[j] = loHead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                newTab[j + oldCap] = hiHead; <span class="comment">//这里j是oldTable的index</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是treeNode就调用treeNode的函数进行split，如果是普通链表就把链表进行拆分成两条链，放到新table的bucket里面。</p>
<h3 id="为什么HashMap在多线程下会死循环（旧版jdk）"><a href="#为什么HashMap在多线程下会死循环（旧版jdk）" class="headerlink" title="为什么HashMap在多线程下会死循环（旧版jdk）"></a>为什么HashMap在多线程下会死循环（旧版jdk）</h3><p>参考资料链接：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html</a>  原链接jdk可能有点老，本文粘贴的源码是jdk10的，所以有些不一样。</p>
<p>一句话概括就是<strong>高并发下，HashMap出现了环形链表，导致get的时候出现了死循环</strong>。涉及到的过程主要就是<strong>resize</strong>。</p>
<p>但是看了一下链接的图，出现环形链需要resize的时候，两个节点前后倒置；但是jdk10里面，新建了两条链，并且维持了顺序，查到资料说还是可能出现死循环。不知如何分析。</p>
<p>有时间可以做一下多线程的实验，并且通过查看堆栈来看cpu占用率和在什么时候做了死循环。</p>
<h3 id="HashMap查询的复杂度为什么是-O-1"><a href="#HashMap查询的复杂度为什么是-O-1" class="headerlink" title="HashMap查询的复杂度为什么是 O(1)"></a>HashMap查询的复杂度为什么是 O(1)</h3><p>参考链接：<a href="http://blog.zhaojie.me/2013/01/think-in-detail-why-its-o-1.html" target="_blank" rel="noopener">http://blog.zhaojie.me/2013/01/think-in-detail-why-its-o-1.html</a></p>
<p>O（1）其实是一种理想的状态，可以看出，每个bucket下其实可能退化成树。如果全部塞key值hash一样，那么hashMap复杂度很可能会退化成O(lgN)。</p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul>
<li>HashMap提供了三个方法，提供三个视图。值得注意的是，在这三个视图之外对HashMap进行修改，都会导致在下次操作iterator的时候modCount不一致抛出异常。<br>具体抛出异常的过程，iterator原理还有待研究。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure>

<ul>
<li>HashMap提供了 <code>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt;</code>这个类，下面有很多算法，暂不研究细节。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HashMap主要是算法和数据结构比较复杂，猜测选择几个默认值的时候进行的测试会比较多，<br>但没有特别复杂的逻辑点。涉及到的数据结构和算法有 hash，树，平衡树，链表。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><h3 id="注释阅读-1"><a href="#注释阅读-1" class="headerlink" title="注释阅读"></a>注释阅读</h3><ul>
<li>LinkedHashMap维护一个双向链表保证塞进map的entry顺序稳定。</li>
<li>一种特殊的 LinkedHashMap 提供了LRU的功能，当对map进行get put等操作的时候，那个Node会被放到前面。</li>
<li>轮询LinkedHashMap时间跟table的真正size相关；轮询HashMap跟capacity相关。所以如果初始化一个较大的InitialCapacity，<br>后果没有HashMap那么严重。<h3 id="源码逻辑-1"><a href="#源码逻辑-1" class="headerlink" title="源码逻辑"></a>源码逻辑</h3>LinkedHashMap是HashMap的子类，它内部的Entry是HashMap.Node的子类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">            Entry&lt;K,V&gt; before, after;</span><br><span class="line">            Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">                <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
field包括<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * for access-order, &#123;<span class="doctag">@code</span> false&#125; for insertion-order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这个类重载了HashMap的方法，例子如下，原理都是在<strong>新增、替换、删除</strong>等操作的时候，维护一下链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建Node之后，链在维护的链表尾部</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LRU的LinkedHashMap"><a href="#LRU的LinkedHashMap" class="headerlink" title="LRU的LinkedHashMap"></a>LRU的LinkedHashMap</h4><p>accessOrder默认是false，意思是，这个链表维护的是insertOrder。可以通过下面的构造函数置true，这样会维护accessOrder。<br>如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e); <span class="comment">// move node to last</span></span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h3><ul>
<li>可以看到，LinkedHashMap新建的三个视图，轮询的时候都是遍历链表，而不是遍历map，</li>
<li>如果accessOrder是true，那么每次进行get操作，node都会转移到链表最后，所以这时候linkedHashMap是least-recently-used cache。<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3>LinkedHashMap跟HashMap相比，有效率和特性上的不同。通过重载各种函数，维护了一个链表；可以看到java面向对象编程的魅力。</li>
</ul>
<h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><ol>
<li>描述一下HashMap put和get的过程</li>
<li>HashMap和HashTable有什么区别，平时用哪个</li>
<li>HashMap线程安全吗？不安全可能出现什么结果？</li>
<li>HashMap和LinkedHashMap区别是什么？</li>
<li>HashMap从1.7到10 做了哪些改进？</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/HashMap/" rel="tag"># HashMap</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/CAS-Happened-Before-Concurrent%E5%8C%85-%E5%85%B3%E4%BA%8Ejava%E4%B8%AD%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%80%E5%88%87.html" rel="next" title="锁, Happened-Before, volatile, atomic, locks 包--java同步">
      锁, Happened-Before, volatile, atomic, locks 包--java同步 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">1.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注释阅读"><span class="nav-number">1.1.</span> <span class="nav-text">注释阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码逻辑"><span class="nav-number">1.2.</span> <span class="nav-text">源码逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fields-and-inner-class"><span class="nav-number">1.2.1.</span> <span class="nav-text">fields and inner class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get"><span class="nav-number">1.2.2.</span> <span class="nav-text">get</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#put"><span class="nav-number">1.2.3.</span> <span class="nav-text">put</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove"><span class="nav-number">1.2.4.</span> <span class="nav-text">remove</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#resize"><span class="nav-number">1.2.5.</span> <span class="nav-text">resize</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么HashMap在多线程下会死循环（旧版jdk）"><span class="nav-number">1.3.</span> <span class="nav-text">为什么HashMap在多线程下会死循环（旧版jdk）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap查询的复杂度为什么是-O-1"><span class="nav-number">1.4.</span> <span class="nav-text">HashMap查询的复杂度为什么是 O(1)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tips"><span class="nav-number">1.5.</span> <span class="nav-text">tips</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">2.</span> <span class="nav-text">LinkedHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注释阅读-1"><span class="nav-number">2.1.</span> <span class="nav-text">注释阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码逻辑-1"><span class="nav-number">2.2.</span> <span class="nav-text">源码逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU的LinkedHashMap"><span class="nav-number">2.2.1.</span> <span class="nav-text">LRU的LinkedHashMap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tips-1"><span class="nav-number">2.3.</span> <span class="nav-text">tips</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">2.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#提问"><span class="nav-number">3.</span> <span class="nav-text">提问</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lawlietxxl</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lawlietxxl</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://lawlietxxl.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: {page: {
            url: "https://blog.lawlietxxl.site/HashMap%20and%20LinkedHashMap.html",
            identifier: "HashMap and LinkedHashMap.html",
            title: "HashMap and LinkedHashMap"
          }
        }
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://lawlietxxl.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
